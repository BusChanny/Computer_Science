# Tree

```
Node 기반의 자료구조
계층 관계를 효과적으로 표현
```

나무를 거꾸로 뒤집어 놓은 형태와 유사해서 트리라고 불린다.<br />
가장 위는 Root Node가 자리잡고, 아래로 가지를 치면서 뻗어 내려오는 구조이다.<br />
그렇다 보니 계층 구조를 표현할 때 효과적으로 사용할 수 있는 자료구조이다.<br />
<br />

---

<br />

### \# 트리를 구성하고 있는 요소들

<br />
<p align="center"><img src="https://user-images.githubusercontent.com/66818228/139432435-10150f2f-abae-4eaf-8130-d108f2aa9caa.png" alt="tree" width="450"/></p>

<br />

- Node: 데이터를 포함하고 트리를 구성하는 요소.
- Edge: 노드와 노드를 연결하는 선.

- Root Node: 부모를 가지지 않는 최상위 노드.
- Leaf Node: 자식이 없는 노드. Terminal Node.
- Internal Node: 리프 노드가 아닌 모든 노드.

- Level: 트리의 특정 깊이를 가지는 노드들의 집합.
- Depth: 루트에서 어떤 노드에 도달하기 위해 거쳐야하는 간선의 수.
- Height: 해당 노드에서 연결된 최하위 노드에 도달하기 위해 거쳐야하는 간선 수.

<br />
<br />

### \# 트리의 특징

<br />

- 하나의 자식 노드는 하나의 부모 노드만 가질 수 있는 그래프의 일종이다.
- 사이클이 없고, 방향성이 있는 그래프이다.
- 하나의 루트 노드가 있다.
- 서로 다른 두 노드를 연결하는 경로가 하나 뿐이다.
- 노드의 개수가 N 개면, 간선은 N - 1개를 가진다.

<br />
<br />

### \# 트리 기반의 자료 구조

<br />

## 이진 트리, Binary Tree

<br />
다양한 트리 기반 자료 구조 중 가장 유명한 것은 이진 트리로, 각 노드의 자식 노드가 2개 이하인 구조이다. 배열이나 연결리스트로 표현이 가능하지만, 배열을 사용할 경우 편향 트리처럼 노드 수가 적으면 사용하지 않는 공간이 많아 비효율적이다. 
<br />
<br />

<p align="center"><img src="https://user-images.githubusercontent.com/66818228/139432483-16f7dc56-827b-456c-a031-c3ebc152574e.png" alt="binary_tree" width="300" /></p>

  
### 이진 트리의 종류

1. 포화 이진 트리: 모든 Internal 노드가 2개의 자식 노드를 가지고 있는 트리 구조.
2. 완전 이진 트리: 마지막 level을 제외하고 모든 level이 왼쪽부터 완전히 채워져 있는 트리 구조. **Heap**에 사용된다.
3. 균형 이진 트리: 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리 구조.
4. 불완전 이진 트리
5. 편향 트리: 모든 노드가 하나의 자식 노드만 가지는 트리구조.
   - Linked List와 성능이 동일하다. 삽입, 검색, 삭제 모두 시간복잡도 O(N). <br />
     → Rebalancing으로 개선된 트리: AVL Tree, Reb-Black Tree 등

<br />
<p align="center"><img src="https://user-images.githubusercontent.com/66818228/139432525-21f141ab-d119-4421-b9d2-1b336ffffe2e.png" alt="tree_type" width="100%" /></p>

<br />
<br />
<br />
<br />

## 이진 탐색 트리, Binary Search Tree

<br />

```
순서를 유지하면서 검색, 삽입, 삭제를 빠르게

::: 균등 트리 : 검색 O(log N) / 삽입 O(log N) / 삭제 O(log N)
::: 편향 트리 : 검색 O(N) / 삽입 O(N) / 삭제 O(N)
```

<br />

### 특정 값을 찾을 때 유용한 이진 탐색 트리

<br />

선형 자료구조인 배열과 해시 테이블을 사용하면 빠른 검색을 할 수 있다. <br />
정렬된 배열에 이진 검색을 사용하면 O(log N)에 어떤 값이든 찾을 수 있고, <br />
해시 테이블을 사용하면 검색, 삽입, 삭제 모두 O(1)로 처리할 수 있다. <br />
<br />
그렇다면 이진 탐색 트리가 필요한 이유는 뭘까?
<br />
<br />
정렬된 배열은 검색이 빠른 대신 삽입과 삭제가 O(N)으로 느리고, <br />
해시 테이블은 순서를 유지하거나 데이터 간의 관계를 표현하지 못하는 단점이 있기 때문에, <br />
순서를 유지하면서도 빠른 검색과 삽입, 삭제가 가능한 이진 탐색 트리 구조를 유용하게 활용할 수 있다.

<br />

이진 탐색 트리는 다음의 규칙을 따르는 이진 트리이다.

<br />

- 노드의 왼쪽 서브 트리에는 그 노드의 값보다 작은 값을 가진 노드들로 이루어져 있다.
- 노드의 오른쪽 서브 트리에는 그 노드의 값보다 큰 값을 가진 노드들로 이루어져 있다.

<br />

이진 탐색 트리를 순회하는 방법은 대표적으로 전위, 중위, 후위, 레벨 순위가 있다. <br />
값을 오름차순으로 출력하려면 **중위 순회**로 좌측 리프 노드부터 차례대로 읽으면 된다.

<br />

<p align="center"><img src="https://user-images.githubusercontent.com/66818228/139432550-aa7489ec-c013-4985-b702-cafe9e909c45.png" alt="traverse" width="100%" /></p>

<br />
<br />

### 삭제

<br />

1. 자식이 없는 leaf 노드이면 → 그냥 삭제한다.
2. 자식이 1개인 노드이면 → 지워진 노드 자리에 자식 노드를 가져온다.
3. 자식이 2개인 노드이면 → 삭제된 노드보다 큰 값들 중 가장 작은 값(후속자 노드)를 가져온다.
   - 만약 후속자 노드에 연결된 자식이 있었다면, 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.

<br />

<p align="center"><img src="https://user-images.githubusercontent.com/66818228/139432564-856ab592-bbd1-4866-a3dd-b6f426491220.png" alt="delete node" width="100%" /></p>



<br />
<br />

---

<br />

## 마무리

<br />

트리는 계층 관계를 효과적으로 표현할 수 있는 노드 기반의 자료 구조이다. 그 중에서도 이진 탐색 트리는 정렬 순서를 유지하면서도, 빠르게 데이터 처리를 할 수 있는 효율적인 자료 구조이다. 정렬된 배열보다 삽입과 삭제 속도가 빠르기 때문에, 데이터를 자주 변경해야 하는 경우 특히 효율적이다. 그 외에도 편향된 트리의 성능을 보완하기 위해, 균형을 맞춰주는 알고리즘이 반영된 Red-black Tree나 AVL Tree도 있다.

<br />

[Balanced Binary Search Tree 보기](./balanced-bst.md)
