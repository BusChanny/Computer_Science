# Encryption & hash

## 목차

[1.서론](#1.서론)   
[2.고전암호](#2.고전암호)   
[3.대칭키와 비대칭키](#3.대칭키와-비대칭키)   
[4.양방향과 단반향](#4.양방향과-단반향)   
[5.Hash](#5.Hash)

### 1.서론

[comment]: <> (![image]&#40;https://user-images.githubusercontent.com/51963264/139436070-67829a1c-1451-489c-934e-ca497074656a.png&#41;)

### 2.고전암호

[comment]: <> (![image]&#40;https://user-images.githubusercontent.com/51963264/139275830-049aa1b0-1fae-4321-b40a-20b3877a7a1e.png&#41;   )
<div>
먼저 암호에 대한 개념을 살펴보자면 다른사람이 알아보지 못하도록 하는 것을`암호화`라고하고 암호화된 문장을 `암호문`이라고 한다.
암호화된 문장을 원래의 문자으로 되돌리는 것을 `복호화`라고 하고 복호화된 원래의 문장을 `평문`이라 한다.


[comment]: <> (![image]&#40;https://user-images.githubusercontent.com/51963264/139278708-b7cd4103-ac57-4fee-b9d8-22da00213c02.png&#41;)


오래 전 부터 암호에 대한 많은 연구가 진행되어 왔다. 단순한 형태로는`치환 암호`와 `전치 암호`가 있다.
치환암호는 평문의 배열은 그대로 두고 문자를 다른 문자로 바꾸는 것으로 카이사르 암호가 이에 해당 한다.
카이사르 암호를 살펴보자면 사전순으로 정렬된 알파벳 배열 두개를 일정한 규칙으로 대응시킨다. 그리고 나서 평문의 알파벳을 대응하는
엇나간 배열의 알파벳으로 바꿔 암호문을 만든다.전치암호는 평문의 문자를 몇개의 문자씩 블록으로 나누고 각 블록 안레서 문자의 순서를 바꾸는 형태이다. 평문을 2차원 배열에 넣은 후
종방향으로 평문을 꺼내 암호화하는 것으로 간단하게 구현 할 수 있다.
</div>
<div>
위에서 보았듯  암호화에서는 변환 규칙(알고리즘)과 키가 핵심이다. 변환규칙은 치환 암호와 전치 암호와 같이 암호화 복호화할때 이렇게 하
하자는 일종의 약속이다. 키는 구체적인 방식이다.카이사르 암호를 예로 들면 3칸 밀어서 대응시킨다고 했을때 '3'에 해당하는것이 키이다.    
여기서 알수 있 듯이 변환 규칙을 알고 있더라고 키를 알지 못하면 복호화할 수 없거나 오랜 시간이 걸릴 것이다. 그래서 이것이 고전 암호가 현대에서 잘 쓰이지 않는 이유이기도 한데
고전 암호는 변환 규칙만 알면 쉽게 복호화 할 수 있다.
</div>

[17289.에니그마](https://www.acmicpc.net/problem/17289) ~~(에니그마가 실버2?)~~



### 3.대칭키와 비대칭키

<div>
변환 규칙이 같더라도 키가 다르면 동일한 평문도 전혀 다른 암호문으로 바꿀 수 있다. 현대에서 주로 사용되고 있는 암호들은 변환 규칙이 알려져도 
키만 다른 사람에게 알려지지 않는다면 안전한 암호들이다. 그래서 오늘날 암호에 있어서 타인으로부터 키를 안전하게 보호하는 것은 중요한 요소이다. 
키를 관리하는 것에는 통신하는 상대가 증가할수록 필요한 키도 늘어나게 되어 방대한 양의 키를 어떻게 관리할 것인가에 대한 문제와 원하는 상대에게 
어떻게 안전하게 키를 전달할것인가에대한 문제 등이 있다.

   

앞서 말한 카이사르 암호는 공통키 암호다. 암호화와 복호화에 동일한 키를 사용해야 정상적으로 작동되기 때문이다. 동일한 키로 암호화 및 복호화를 진행할수 있기 떄문에
쉽게 구현할 수 있고  처리속도가 비교적 짧아 실용적일 수 있다. 공통키암호는 앞서 말한 키관리 문제를 해결하지 못한다. 이를 해결한 암호화 방식이
공개키 암호다. 암호화와 복호화에 사용되는 키를 키페어라고 한다. 이 키페어는 서로 다르다. 그래서 비대칭암호라고 한다. 키페어는 공개키와 비밀키로 구성된다. 
이름에서 알수 있듯이 공개키는 제3자에게 공개되어도 상관없지만 비밀키는 본인 이외에는 절대로 노출되면 안된다.

비대칭 작동 방식을 살펴보면, A가 B에게 데이터를 송신할 때,B씨는 공개키를 A에게 공개한다. A는 B가 공개한 공개키를 이용해서 평문을 암호화한다.
그것을 전달받은 B는 비밀키를 이용해 복호화한다. 당연히 비밀키는 B밖에 가지고 있지 않기 때문에 중간에 누군가가 가로챈다고 하더라도 암호문을 복호화될 위험은 적다
비대칭키는 '어떻게 안전하게 전달할것인가'라는 문제와 '키가 방대해지는 것을 어떻게 관리할것인가라'는 문제를 해결할 수 있다. 아무리 많은 사람과 통신하더라도
비대칭키는 그와 비례해서 증가하는 것이 아니다. 그리고 암호화에 필요한 키와 복호화에 필요한 키가 다르기 때문에 복호화를 위해 키를 상대에게 전달할
필요가 없다. 하지만 장점만 있는건 아니다. 처리과정이 비교적 복잡하기 때문에 용량이 큰 데이터에는 적합하지가 않다. 처리속도 느려지면 그 만큼 효율이
떨어지기 때문이다. 또한 신뢰성에 대한 문제도 있다. 만약 누군가가 B를 가장하고 A에게 공개키를 넘긴다면 비대칭키가 아무리 견고하더라도 무용지물이 
되어 버린다. 이를 방지하기 위해 올바른 상대인지 보장하는 인증서와 인증기관등이 잇다.
</div>

### 4.양방향과 단반향
<div>
앞서 살펴본 것들은 양방향 암호화이다. 암호화란게 평문을 키를 이용해 해독할수 없는 형태로 변경한 것을 말하는데 복호화 가능 여부에 따라 양방향,
단방향으로 나뉜다. 단방향 암호화는 복호화가 불가능한 암호화로 심지어 암호화한 사람도 복호화가 불가능 하다. 일반적으로 이런 단방향 암호화는 Hash
기법을 만들어 진다. Hash의 사전적 의미를 보면 다지다 으깨다란 뜻이다. 마치 포도로 포도주를 만들 듯 나무로 종이를 만들 듯 데이터를 원래상태로 
되돌릴 수 없게 할 뿐만아니라 일정한 크기로 만들어준다. 얼핏 생각해보면 복호화가 불가능하면 쓸모없는 것이 아닐까란 생각이 든다.
</div>

### 5.Hash

<div>
비밀번호를 검증할때 Hash를 이용하는 것은 좋은 방법이다. 입력된 비밀번호를 그대로 저장한다면 노출되었을 때 큰 문제가 될수 있다. 만약
비밀번호의 해시값을 보관한다면 정보가 외부 노출 되더라도  원본을 바로 알 수 없다.그와 동시에 비밀번호 원본을 비교하는 것이 아니라 해쉬값을 비교함으로써
로그인 처리를 수행 할수 있다. 또한 송수신처리 작업이 성공적으로 완료 했다 하더라도 경로상 손상되었다면 문제가 발생할 수 있다. 
따라서 송신된 데이터와 수신된 데이터가 동일하다는 것을 확인할 필요가 있다.이러한 필요에 의해서 Hash가 사용되며 송신된 데이터와 수신된 데이터의
해쉬값을 비교함으로써 올바른 데이터인지 판단할 수 있다.

해쉬의 핵심은 무결성에 있다. 데이터가 변경이 되지 않았다는 것을 검증하기 쓰인다. 그렇다면 이 무결성이 어떻게 지켜지는지 알 필요가 있다.

[12829.Hashing](https://www.acmicpc.net/problem/15829) ~~(직접만들어보자)~~

```
h(x) = x mod m
```
이때 해시값이 고루 분포될수 있도록 정교하게 만들 필요가 있는데 m은 2의 거듭제곱에 가깝지 않은 소수를 택하는 것이 좋다. m이 소수가 아닐 때 산출값
이 특정 값에 편향되는 경우가 있기 때문이다. 이런 경우를 해시충돌이라고 하는데 충돌이 일어날 확률이 적게 설계해야 한다. 하지만 필연적으로 해시충돌은
존재할 수 밖에 없다.

</div>


해쉬를 이용한 암호화의 특징은 다음과 같다.

- 임의의 길이를 가진 입력 데이터에 대해 고정 길이의 해시 값을 출력한다.
- 해시값을 빠르게 계산가능하다.
- 일방향성을 갖는다.
- 입력데이터가 조금만 변해도 완전히 다른 해쉬값을 얻을 수 있다.

또한 해쉬 함수가 갖는 세가지 성질은 다음과 같다.

- 역상 저항성(Preimage resistance)   
  결과물(해시값)으로부터 원본을 유추 할 수 없어야 한다.
  역을 구하는 것이 어렵도록 설계해야된다 
  
  
- 제2 역상 저항성(Second preimage resistance)   
  h(x) = y 일때, x와 y를 알고 있는 경우, h(x') = y 인 x' 을 찾는 것이 어려워야한다.   
  

- 출동 저항성(Collision resistance)   
  h(x) = h(x') 인 x, x' 을 찾는 것이 어려워야한다(해시 충돌을 찾는 것이 어려워야 한다)
  



















